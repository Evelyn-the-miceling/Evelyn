import csv
from collections import defaultdict, Counter
import random

# --- Helper Functions for Data Processing ---

def readfile(filename="records.csv"):
    """
    Reads the CSV file, converts each row to a dictionary, and groups
    students into a dictionary keyed by their 'Tutorial Group'.
    """
    students_by_group = defaultdict(list)
    try:
        with open(filename, mode='r', encoding='utf-8') as file:
            # Use DictReader to handle headers and commas within data correctly
            csv_reader = csv.DictReader(file)
            
            for row in csv_reader:
                try:
                    # Convert CGPA and Student ID to numerical types
                    row['CGPA'] = float(row['CGPA'])
                    row['Student ID'] = int(row['Student ID'])
                    
                    # Add student dictionary to the correct group list
                    students_by_group[row['Tutorial Group']].append(row)
                except ValueError:
                    # Skip rows with non-convertible data
                    continue
                    
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return None

    return students_by_group

def get_cgpa_tier(cgpa):
    """Classifies CGPA into a tier (High, Mid, Low) for balancing."""
    if cgpa >= 4.0:
        return 'High'
    elif cgpa >= 3.8:
        return 'Mid'
    else:
        return 'Low'

# --- Core Allocation Logic ---

def allocate_teams_for_group(students, group_name):
    """
    Allocates 10 teams of 5 for a single tutorial group using the
    "Case 2" strategy with constraint checks.
    """
    if len(students) != 50:
        # Should not happen based on file data, but good check
        return []

    # 1. Separate and Sort (User's Case 2 Logic)
    males = [s for s in students if s['Gender'] == 'Male']
    females = [s for s in students if s['Gender'] == 'Female']
    
    # Sort boys desc, girls asc to mix high/low CGPA
    males.sort(key=lambda s: s['CGPA'], reverse=True)
    females.sort(key=lambda s: s['CGPA'], reverse=False)
    
    # Combine students into a single pool in a way that mixes M/F and CGPA
    sorted_pool = []
    while males or females:
        # Prioritize taking from both ends to maximize mix
        if males:
            sorted_pool.append(males.pop(0)) # High CGPA Male
        if females:
            sorted_pool.append(females.pop(0)) # Low CGPA Female
        
        # Add remaining students (which are now mostly the lower-priority end of the lists)
        if males:
            sorted_pool.extend(males)
            males = []
        if females:
            sorted_pool.extend(females)
            females = []
    
    # Randomize the pool slightly to prevent perfect ordering bias
    random.shuffle(sorted_pool)
    
    # 2. Initialize Teams
    num_teams = 10
    teams = [[] for _ in range(num_teams)]
    
    # 3. Place Students (Build-as-you-go strategy with checks)
    for student in sorted_pool:
        is_placed = False
        
        # Shuffle team order to distribute "difficult" students evenly across teams
        team_indices = list(range(num_teams))
        random.shuffle(team_indices)
        
        for i in team_indices:
            team = teams[i]
            
            # Constraint 1: Team size must be less than 5
            if len(team) >= 5:
                continue

            # Get current constraints for the team
            current_genders = Counter(s['Gender'] for s in team)
            current_schools = Counter(s['School'] for s in team)
            
            # Constraint 2: Max 2 of the same Gender (no majority)
            if current_genders[student['Gender']] >= 2:
                continue
            
            # Constraint 3: Max 2 from the same School (no majority)
            if current_schools[student['School']] >= 2:
                continue

            # Constraint 4: Balance CGPA (Preventing all 5 high/low teams)
            # Only check when the team has 4 members (i.e., adding this one makes 5)
            if len(team) == 4:
                # Predict the CGPA tiers if the student is added
                future_tiers = Counter(get_cgpa_tier(s['CGPA']) for s in team)
                future_tiers[get_cgpa_tier(student['CGPA'])] += 1
                
                # If adding this student makes an all-High or all-Low team, skip
                if future_tiers['High'] == 5 or future_tiers['Low'] == 5:
                    continue
            
            # If all checks pass, place the student in the team
            team.append(student)
            is_placed = True
            break
            
        if not is_placed:
            # Fallback: If a student cannot be placed perfectly, place them in the first
            # available team that needs a member. This forces allocation completion
            # (acceptable under the "Some tolerance is acceptable" clause).
            for team in teams:
                if len(team) < 5:
                    team.append(student)
                    break

    # 4. Assign Team IDs and Flatten the List
    final_allocated_students = []
    for i, team in enumerate(teams):
        for student in team:
            student['Team Assigned'] = f"{group_name}-T{i + 1}"
            final_allocated_students.append(student)
            
    return final_allocated_students

# --- Output Function ---

def write_output_csv(all_students_with_teams, output_filename):
    """
    Writes the final list of students to a new CSV file.
    """
    if not all_students_with_teams:
        return

    # Columns required by the project manual
    header = [
        "Tutorial Group", "Student ID", "School", "Name", 
        "Gender", "CGPA", "Team Assigned"
    ]
    
    try:
        with open(output_filename, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.DictWriter(file, fieldnames=header)
            writer.writeheader()
            
            for student in all_students_with_teams:
                # Create output row with only required fields
                output_row = {col: student.get(col, "UNASSIGNED") for col in header}
                writer.writerow(output_row)
                
        # print(f"\nSuccessfully created team allocations file: {output_filename}")
        
    except Exception as e:
        print(f"Error writing to output file: {e}")

# --- Main Execution ---

def run_allocation():
    groups = readfile()

    if not groups:
        return

    final_allocations = []
    
    # Process all 120 groups
    for group_name, students in groups.items():
        allocated_students = allocate_teams_for_group(students, group_name)
        final_allocations.extend(allocated_students)
    
    # Write the final output file
    # NOTE: Remember to rename 'team_allocations.csv' to the required format for submission: 
    # e.g., FDBA_Team1_YourName.csv
    write_output_csv(final_allocations, "team_allocations.csv")

# Execute the main function
if __name__ == "__main__":
    run_allocation()

