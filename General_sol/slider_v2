import csv
import math
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider

# --- CONFIGURATION ---
INPUT_FILE = 'OutputFile.csv'
INITIAL_TEAM_SIZE = 5

# --- GLOBAL DATA STORAGE ---
raw_data = [] 

# --- 1. ROBUST DATA LOADER (Fixes 'Subgroups' error) ---
def load_data_into_memory(file_path):
    data = []
    print(f"--- Loading data from {file_path} ---")
    try:
        with open(file_path, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            header = next(reader)
            
            # Auto-detect the Team Column
            if 'Subgroups' in header:
                team_col = 'Subgroups'
            elif 'Team Assigned' in header:
                team_col = 'Team Assigned'
            else:
                print(f"Error: Could not find 'Subgroups' or 'Team Assigned' in {header}")
                return []

            col_index = {
                'Tutorial Group': header.index('Tutorial Group'),
                'Gender': header.index('Gender'),
                'CGPA': header.index('CGPA'),
                'School': header.index('School'),
                'Team': header.index(team_col), # Use detected name
            }
            
            for row in reader:
                if len(row) <= max(col_index.values()): continue
                try:
                    cgpa = float(row[col_index['CGPA']])
                except ValueError:
                    continue
                    
                data.append({
                    'tut_group': row[col_index['Tutorial Group']],
                    'team': row[col_index['Team']],
                    'gender': row[col_index['Gender']],
                    'school': row[col_index['School']],
                    'cgpa': cgpa
                })
            print(f"Loaded {len(data)} student records.")
            return data
    except Exception as e:
        print(f"Error loading data: {e}")
        return []

# --- 2. MATH HELPERS ---
def calculate_mean(data):
    if not data: return 0.0
    return sum(data) / len(data)

def calculate_std_dev(data, mean_value):
    N = len(data)
    if N < 2: return 0.0
    sum_sq_diff = sum([(x - mean_value) ** 2 for x in data])
    return math.sqrt(sum_sq_diff / N)

# --- 3. FLEXIBLE ANALYSIS (Fixes "Other" Issue) ---
def run_analysis(required_n, student_records):
    tut_groups_map = {}
    
    # Group Data
    for s in student_records:
        tg = s['tut_group']
        tm = s['team']
        if tg not in tut_groups_map: tut_groups_map[tg] = {}
        if tm not in tut_groups_map[tg]: tut_groups_map[tg][tm] = []
        tut_groups_map[tg][tm].append(s)

    # --- 1. PRE-FILL GENDER KEYS (Target N) ---
    # We create 0-count entries for the target size (e.g. 9:0, 8:1...)
    gender_counts = {}
    if required_n > 0:
        for m in range(required_n, -1, -1):
            gender_counts[f"{m}:{required_n-m}"] = 0
    
    # School & SD Setup
    school_counts = {i: 0 for i in range(1, required_n + 1)}
    sd_bins = [round(i * 0.01, 2) for i in range(17)]
    sd_counts = {f'{sd_bins[i]:.2f}-{sd_bins[i+1]:.2f}': 0 for i in range(len(sd_bins)-1)}
    sd_counts['>0.15'] = 0

    # --- PROCESS TEAMS ---
    for tg, teams in tut_groups_map.items():
        team_means = []
        
        for tm, students in teams.items():
            size = len(students)
            
            # --- GENDER LOGIC (Dynamic) ---
            # Instead of forcing "Other", we simply ADD the actual ratio found
            m_count = sum(1 for s in students if s['gender'] == 'Male')
            f_count = size - m_count
            ratio_key = f"{m_count}:{f_count}"
            
            if ratio_key in gender_counts:
                gender_counts[ratio_key] += 1
            else:
                # If this ratio wasn't expected (e.g. size 5 when N=9), add it dynamically!
                # This prevents it from being hidden in "Other"
                gender_counts[ratio_key] = 1

            # School Logic
            uniq_sch = len(set(s['school'] for s in students))
            if uniq_sch in school_counts:
                school_counts[uniq_sch] += 1
            else:
                school_counts[uniq_sch] = 1 # Dynamic handling
            
            # CGPA Logic
            cgpas = [s['cgpa'] for s in students]
            team_means.append(calculate_mean(cgpas))

        # Standard Deviation Logic
        if len(team_means) >= 2:
            grp_mean = calculate_mean(team_means)
            sd = calculate_std_dev(team_means, grp_mean)
            
            matched = False
            if sd > 0.15:
                sd_counts['>0.15'] += 1
                matched = True
            else:
                for i in range(len(sd_bins) - 1):
                    if sd_bins[i] < sd <= sd_bins[i+1]:
                        sd_counts[f'{sd_bins[i]:.2f}-{sd_bins[i+1]:.2f}'] += 1
                        matched = True
                        break
                if not matched and 0.0 <= sd <= 0.01:
                     sd_counts['0.00-0.01'] += 1

    return gender_counts, school_counts, sd_counts

# --- 4. PLOTTING & SORTING ---
def main():
    global raw_data
    raw_data = load_data_into_memory(INPUT_FILE)
    if not raw_data: return

    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))
    plt.subplots_adjust(left=0.1, bottom=0.15, right=0.95, top=0.95, hspace=0.5)

    ax_slider = plt.axes([0.25, 0.05, 0.5, 0.03], facecolor='lightgoldenrodyellow')
    slider_n = Slider(ax_slider, 'Target Size (N)', 2, 10, valinit=INITIAL_TEAM_SIZE, valstep=1)

    def update(val):
        N = int(slider_n.val)
        g_counts, s_counts, sd_counts = run_analysis(N, raw_data)

        # --- PLOT 1: GENDER (Sorted by Team Size, then Male Count) ---
        ax1.clear()
        # Custom Sort: 1. Total Size (Descending), 2. Male Count (Descending)
        # This keeps Size 9 bars separate from Size 5 bars
        labels_g = sorted(g_counts.keys(), 
                          key=lambda k: (int(k.split(':')[0])+int(k.split(':')[1]), int(k.split(':')[0])), 
                          reverse=True)
        
        vals_g = [g_counts[k] for k in labels_g]
        
        # Highlight bars that match the Target Size N
        colors_g = []
        for label in labels_g:
            m, f = map(int, label.split(':'))
            if (m + f) == N: colors_g.append('#5dade2') # Blue for match
            else: colors_g.append('#e74c3c') # Red for mismatch size
            
        ax1.bar(labels_g, vals_g, color=colors_g)
        ax1.set_title(f"Gender Diversity (Blue = Target N={N}, Red = Mismatch)")
        ax1.set_ylabel("Count")
        ax1.grid(axis='y', linestyle='--')

        # --- PLOT 2: SCHOOL ---
        ax2.clear()
        labels_s = sorted(s_counts.keys(), reverse=True)
        vals_s = [s_counts[k] for k in labels_s]
        ax2.bar([str(x) for x in labels_s], vals_s, color='#2ecc71')
        ax2.set_title("School Diversity (Unique Schools per Team)")
        ax2.grid(axis='y', linestyle='--')

        # --- PLOT 3: SD ---
        ax3.clear()
        labels_sd = sorted(sd_counts.keys())
        if '>0.15' in labels_sd:
            labels_sd.remove('>0.15'); labels_sd.append('>0.15')
        vals_sd = [sd_counts[k] for k in labels_sd]
        
        ax3.bar(labels_sd, vals_sd, color='#f39c12')
        ax3.set_title("CGPA Consistency (SD of Team Means)")
        ax3.tick_params(axis='x', rotation=45)
        ax3.grid(axis='y', linestyle='--')

        fig.canvas.draw_idle()

    slider_n.on_changed(update)
    update(INITIAL_TEAM_SIZE)
    plt.show()

if __name__ == "__main__":
    main()